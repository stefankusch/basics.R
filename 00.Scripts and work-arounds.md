As problems are encountered they need to be solved. Sometimes you may need a custom solution for your analysis, sometimes you need a standard function that solves your problem. Here, I collect such instances and how they were solved. 

1. Infinite values (-Inf, Inf, NA, ...)
2. **R** sorting rows alphabetically
3. Plotting multiple lines in one plot
4. Counting instances in a column with `plyr`
5. 

#### Infinite values

Infinite values like `Inf`, `-Inf`, `NA`, or `NaN` can cause trouble in your analysis and are especially annoying in larger datasets. I found the following solution:

```
df <- as.data.frame(lapply(your.data, function(x){replace(x, x=="-Inf",0)}))
df <- as.data.frame(lapply(your.data, function(x){replace(x, x <0,0)}))
```
The first line finds all `-Inf` in the data frame of `your.data` and replaces them with `0`, the second line finds all values that are negative. I called the new data frame `df` here, but such replacements can also be run subsequently, naming the new data frame as the old. Some solutions claimed that e.g. `is.finite(NA)` or `is.infinite(Inf)` would help here as well, but that never worked in my case. 


#### R sorting rows alphabetically

In many instances, **R** automatically sorts lists by name for processing. This is not always useful, because sometimes the list is ordered by a different value and should not be changed. You can order your list by a column `$column.name` in a custom manner using
```
list.ordered <- list.data[order(your.data$column.name,decreasing=TRUE),]
```
In one instance, i.e. drawing heatmaps with `ggplot2`, I solved this using the following line within the heatmap command:
```
ylim(rev(levels(factor(identifier, levels = unique(as.character(list.ordered[[1]]))))))
```
With `rev()` the order was kept but reversed. The `identifier` refers to the columns with the row names, and `levels = unique(as.character(list.ordered[[1]]))` defines the order of the data. 


#### Plotting multiple lines in one plot

The function `matplot` can be used to plot multiple lines in one graph. Here, four time points are used in a time course analysis; therefore, the axis is defined with four ticks `at=c(1,2,3,4,)`. 
```R
matplot(x, y, type="l", col="black", lwd=1, lty=1, xaxt="n", xlab="time [hpi]", ylab=expression("norm.expression [FPKM]"))
axis(side = 1, at=c(1,2,3,4), labels = c("6","12","18","24"))
```
Then, more lines can be drawn with `lines()`.
```R
lines(x,y)
```


#### Counting instances in a column with `plyr`

In simple cases, counting can be done with `length(which())` or `sum()`. 
```
```
However, if the matrix is more complex (e.g., many different things to count), `plyr` offers a very useful and simple solution. Let's assume the column of `your.data` you want to count is called `phenotypes`:
```R
library(plyr)
df.count<-count(your.data, "phenotypes")
```
which gives
```R
> head(df.count)
    phenotype  freq
1  healthy     4
2  symptoms    2
3  senescence  10
4  necrosis    32
5  death       22
```
If you want to sort by the column with the counts:
```R
df.count[order(df.count$freq,decreasing=TRUE),]

    phenotype  freq
4  necrosis    32
5  death       22
3  senescence  10
1  healthy     4
2  symptoms    2
```
